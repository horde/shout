<?xml version="1.0"?>
<asterisk type="applist">    <application name="SayAlpha">
        <synopsis>Say Alpha</synopsis>
        <usage>  SayAlpha(string): Spells the passed string

</usage>
    </application>
    <application name="TxFAX">
        <synopsis>Send a FAX file</synopsis>
        <usage>  TxFAX(filename[|option]):  Send a given file name as a FAX. Returns -1
Uses LOCALSTATIONID to identify itself to the remote end.
Sets REMOTESTATIONID to the receiver CSID.
Returns -1 when the user hangs up, or if the file does not exist.
Returns 0 otherwise.

</usage>
    </application>
    <application name="VoiceMailMain">
        <synopsis>Enter voicemail system</synopsis>
        <usage>  VoiceMailMain([[s]mailbox][@context]): Enters the main voicemail system
for the checking of voicemail.  The mailbox can be passed as the option,
which will stop the voicemail system from prompting the user for the mailbox.
If the mailbox is preceded by &#39;s&#39; then the password check will be skipped.  If
the mailbox is preceded by &#39;p&#39; then the supplied mailbox is prepended to the
user&#39;s entry and the resulting string is used as the mailbox number.  This is
useful for virtual hosting of voicemail boxes.  If a context is specified,
logins are considered in that voicemail context only.
Returns -1 if the user hangs up or 0 otherwise.

</usage>
    </application>
    <application name="StripLSD">
        <synopsis>Strip Least Significant Digits</synopsis>
        <usage>  StripLSD(count): Strips the trailing  &#39;count&#39;  digits  from  the  channel&#39;s
associated extension. For example, the  number  5551212 when stripped with a
count of 4 would be changed to 555.  This app always returns 0, and the PBX
will continue processing at the next priority for the *new* extension.
  So, for  example, if  priority 3 of 5551212  is  StripLSD 4, the next step
executed will be priority 4 of 555.  If you switch into an  extension which
has no first step, the PBX will treat it as though the user dialed an
invalid extension.

</usage>
    </application>
    <application name="ChangeMonitor">
        <synopsis>Change monitoring filename of a channel</synopsis>
        <usage>ChangeMonitor(filename_base)
Changes monitoring filename of a channel. Has no effect if the channel is not monitored
The argument is the new filename base to use for monitoring this channel.

</usage>
    </application>
    <application name="BackgroundDetect">
        <synopsis>Background a file with talk detect</synopsis>
        <usage>  BackgroundDetect(filename[|sil[|min|[max]]]):  Plays  back  a  given
filename, waiting for interruption from a given digit (the digit must
start the beginning of a valid extension, or it will be ignored).
During the playback of the file, audio is monitored in the receive
direction, and if a period of non-silence which is greater than &#39;min&#39; ms
yet less than &#39;max&#39; ms is followed by silence for at least &#39;sil&#39; ms then
the audio playback is aborted and processing jumps to the &#39;talk&#39; extension
if available.  If unspecified, sil, min, and max default to 1000, 100, and
infinity respectively.  Returns -1 on hangup, and 0 on successful playback
completion with no exit conditions.

</usage>
    </application>
    <application name="SayNumber">
        <synopsis>Say Number</synopsis>
        <usage>  SayNumber(digits[,gender]): Says the passed number. SayNumber is using
the current language setting for the channel. (See app SetLanguage).

</usage>
    </application>
    <application name="Directory">
        <synopsis>Provide directory of voicemail extensions</synopsis>
        <usage>  Directory(vm-context[|dial-context[|options]]): Presents the user with a directory
of extensions from which they  may  select  by name. The  list  of  names 
and  extensions  is discovered from  voicemail.conf. The  vm-context  argument
is required, and specifies  the  context  of voicemail.conf to use.  The
dial-context is the context to use for dialing the users, and defaults to
the vm-context if unspecified. The &#39;f&#39; option causes the directory to match
based on the first name in voicemail.conf instead of the last name.
Returns 0 unless the user hangs up. It  also sets up the channel on exit
to enter the extension the user selected.

</usage>
    </application>
    <application name="SetCallerID">
        <synopsis>Set CallerID</synopsis>
        <usage>  SetCallerID(clid[|a]): Set Caller*ID on a call to a new
value.  Sets ANI as well if a flag is used.  Always returns 0

</usage>
    </application>
    <application name="Congestion">
        <synopsis>Indicate congestion and stop</synopsis>
        <usage>  Congestion([timeout]): Requests that the channel indicate congestion
and then waits for the user to hang up or for the optional timeout to
expire.  Always returns -1.
</usage>
    </application>
    <application name="Busy">
        <synopsis>Indicate busy condition and stop</synopsis>
        <usage>  Busy([timeout]): Requests that the channel indicate busy condition and
then waits for the user to hang up or the optional timeout to expire.
Always returns -1.
</usage>
    </application>
    <application name="Park">
        <synopsis>Park yourself</synopsis>
        <usage>Park(exten):Used to park yourself (typically in combination with a supervised
transfer to know the parking space.  This Application is always
registered internally and does not need to be explicitly added
into the dialplan, although you should include the &#39;parkedcalls&#39;
context.

</usage>
    </application>
    <application name="VoiceMail">
        <synopsis>Leave a voicemail message</synopsis>
        <usage>  VoiceMail([s|u|b]extension[@context][&amp;extension[@context]][...]):  Leavesvoicemail for a given extension (must be configured in voicemail.conf).
 If the extension is preceded by 
* &#39;s&#39; then instructions for leaving the message will be skipped.
* &#39;u&#39; then the &quot;unavailable&quot; message will be played.
  (/var/lib/asterisk/sounds/vm/&lt;exten&gt;/unavail) if it exists.
* &#39;b&#39; then the the busy message will be played (that is, busy instead of unavail).
If the caller presses &#39;0&#39; (zero) during the prompt, the call jumps to
extension &#39;o&#39; in the current context.
If the caller presses &#39;*&#39; during the prompt, the call jumps to
extension &#39;a&#39; in the current context.
If the requested mailbox does not exist, and there exists a priority
n + 101, then that priority will be taken next.
When multiple mailboxes are specified, the unavailable or busy message
will be taken from the first mailbox specified.
Returns -1 on error or mailbox not found, or if the user hangs up.
Otherwise, it returns 0.

</usage>
    </application>
    <application name="Wait">
        <synopsis>Waits for some time</synopsis>
        <usage>  Wait(seconds): Waits for a specified number of seconds, then returns 0.
seconds can be passed with fractions of a second. (eg: 1.5 = 1.5 seconds)

</usage>
    </application>
    <application name="CallingPres">
        <synopsis>Change the presentation for the callerid</synopsis>
        <usage>Callingpres(number): Changes the presentation for the callerid. Should be called before placing an outgoing call

</usage>
    </application>
    <application name="MusicOnHold">
        <synopsis>Play Music On Hold indefinitely</synopsis>
        <usage>MusicOnHold(class): Plays hold music specified by class.  If omitted, the default
music source for the channel will be used. Set the default 
class with the SetMusicOnHold() application.
Returns -1 on hangup.
Never returns otherwise.

</usage>
    </application>
    <application name="AbsoluteTimeout">
        <synopsis>Set absolute maximum time of call</synopsis>
        <usage>  AbsoluteTimeout(seconds): Set the absolute maximum amount of time permitted
for a call.  A setting of 0 disables the timeout.  Always returns 0.

</usage>
    </application>
    <application name="VoiceMailMain2">
        <synopsis>Enter voicemail system</synopsis>
        <usage>  VoiceMailMain([[s]mailbox][@context]): Enters the main voicemail system
for the checking of voicemail.  The mailbox can be passed as the option,
which will stop the voicemail system from prompting the user for the mailbox.
If the mailbox is preceded by &#39;s&#39; then the password check will be skipped.  If
the mailbox is preceded by &#39;p&#39; then the supplied mailbox is prepended to the
user&#39;s entry and the resulting string is used as the mailbox number.  This is
useful for virtual hosting of voicemail boxes.  If a context is specified,
logins are considered in that voicemail context only.
Returns -1 if the user hangs up or 0 otherwise.

</usage>
    </application>
    <application name="BackGround">
        <synopsis>Play a file while awaiting extension</synopsis>
        <usage>  Background(filename[|options[|langoverride]]): Plays a given file, while simultaneously
waiting for the user to begin typing an extension. The  timeouts do not
count until the last BackGround application has ended.
Options may also be  included following a pipe symbol. The &#39;skip&#39;
option causes the playback of the message to  be  skipped  if  the  channel
is not in the &#39;up&#39; state (i.e. it hasn&#39;t been  answered  yet. If &#39;skip&#39; is 
specified, the application will return immediately should the channel not be
off hook.  Otherwise, unless &#39;noanswer&#39; is specified, the channel channel will
be answered before the sound is played. Not all channels support playing
messages while still hook. The &#39;langoverride&#39; may be a language to use for
playing the prompt which differs from the current language of the channel
Returns -1 if the channel was hung up, or if the file does not exist. 
Returns 0 otherwise.

</usage>
    </application>
    <application name="Verbose">
        <synopsis>Send arbitrary text to verbose output</synopsis>
        <usage>Verbose([&lt;level&gt;|]&lt;message&gt;)
  level must be an integer value.  If not specified, defaults to 0.  Always returns 0.

</usage>
    </application>
    <application name="StopMonitor">
        <synopsis>Stop monitoring a channel</synopsis>
        <usage>StopMonitor
Stops monitoring a channel. Has no effect if the channel is not monitored

</usage>
    </application>
    <application name="SubString">
        <synopsis>(Deprecated) Save substring digits in a given variable</synopsis>
        <usage>  (Deprecated, use ${variable:a:b} instead)

  SubString(variable=string_of_digits|count1|count2): Assigns the substring
of string_of_digits to a given variable. Parameter count1 may be positive
or negative. If it&#39;s positive then we skip the first count1 digits from the
left. If it&#39;s negative, we move count1 digits counting from the end of
the string to the left. Parameter count2 implies how many digits we are
taking from the point that count1 placed us. If count2 is negative, then
that many digits are omitted from the end.
For example:
exten =&gt; _NXXXXXX,1,SubString,test=2564286161|0|3
assigns the area code (3 first digits) to variable test.
exten =&gt; _NXXXXXX,1,SubString,test=2564286161|-7|7
assigns the last 7 digits to variable test.
exten =&gt; _NXXXXXX,1,SubString,test=2564286161|0|-4
assigns all but the last 4 digits to variable test.
If there are no parameters it&#39;ll return with -1.
If there wrong parameters it go on and return with 0

</usage>
    </application>
    <application name="MeetMeCount">
        <synopsis>MeetMe participant count</synopsis>
        <usage>  MeetMeCount(confno[|var]): Plays back the number of users in the specifiedi
MeetMe conference. If var is specified, playback will be skipped and the value
will be returned in the variable. Returns 0 on success or -1 on a hangup.
A ZAPTEL INTERFACE MUST BE INSTALLED FOR CONFERENCING FUNCTIONALITY.

</usage>
    </application>
    <application name="SetCIDName">
        <synopsis>Set CallerID Name</synopsis>
        <usage>  SetCIDName(cname[|a]): Set Caller*ID Name on a call to a new
value, while preserving the original Caller*ID number.  This is
useful for providing additional information to the called
party. Sets ANI as well if a flag is used.  Always returns 0

</usage>
    </application>
    <application name="Flash">
        <synopsis>Flashes a Zap Trunk</synopsis>
        <usage>  Flash(): Sends a flash on a zap trunk.  This is only a hack for
people who want to perform transfers and such via AGI and is generally
quite useless otherwise.  Returns 0 on success or -1 if this is not
a zap trunk

</usage>
    </application>
    <application name="Suffix">
        <synopsis>Append trailing digits</synopsis>
        <usage>  Suffix(digits): Appends the  digit  string  specified  by  digits to the
channel&#39;s associated extension. For example, the number 555 when  suffixed
with &#39;1212&#39; will become 5551212. This app always returns 0, and the PBX will
continue processing at the next priority for the *new* extension.
  So, for example, if priority  3  of  555 is Suffix 1212, the  next  step
executed will be priority 4 of 5551212. If  you  switch  into an  extension
which has no first step, the PBX will treat it as though the user dialed an
invalid extension.

</usage>
    </application>
    <application name="SetAccount">
        <synopsis>Sets account code</synopsis>
        <usage>  SetAccount([account]):  Set  the  channel account code for billing
purposes. Always returns 0.

</usage>
    </application>
    <application name="SayPhonetic">
        <synopsis>Say Phonetic</synopsis>
        <usage>  SayPhonetic(string): Spells the passed string with phonetic alphabet

</usage>
    </application>
    <application name="Monitor">
        <synopsis>Monitor a channel</synopsis>
        <usage>Monitor([file_format|[fname_base]|[options]]):
Used to start monitoring a channel. The channel&#39;s input and output
voice packets are logged to files until the channel hangs up or
monitoring is stopped by the StopMonitor application.
  file_format		optional, if not set, defaults to &quot;wav&quot;
  fname_base		if set, changes the filename used to the one specified.
  options:
    m   - when the recording ends mix the two leg files into one and
          delete the two leg files.  If the variable MONITOR_EXEC is set, the
          application referenced in it will be executed instead of
          soxmix and the raw leg files will NOT be deleted automatically.
          soxmix or MONITOR_EXEC is handed 3 arguments, the two leg files
          and a target mixed file name which is the same as the leg file names
          only without the in/out designator.
          If MONITOR_EXEC_ARGS is set, the contents will be passed on as
          additional arguements to MONITOR_EXEC
          Both MONITOR_EXEC and the Mix flag can be set from the
          administrator interface

    b   - Don&#39;t begin recording unless a call is bridged to another channel

Returns -1 if monitor files can&#39;t be opened or if the channel is already
monitored, otherwise 0.

</usage>
    </application>
    <application name="WaitMusicOnHold">
        <synopsis>Wait, playing Music On Hold</synopsis>
        <usage>WaitMusicOnHold(delay): Plays hold music specified number of seconds.  Returns 0 when
done, or -1 on hangup.  If no hold music is available, the delay will
still occur with no sound.

</usage>
    </application>
    <application name="Answer">
        <synopsis>Answer a channel if ringing</synopsis>
        <usage>  Answer(): If the channel is ringing, answer it, otherwise do nothing. 
Returns 0 unless it tries to answer the channel and fails.

</usage>
    </application>
    <application name="Echo">
        <synopsis>Echo audio read back to the user</synopsis>
        <usage>  Echo():  Echo audio read from channel back to the channel. Returns 0
if the user exits with the &#39;#&#39; key, or -1 if the user hangs up.

</usage>
    </application>
    <application name="SayDigits">
        <synopsis>Say Digits</synopsis>
        <usage>  SayDigits(digits): Says the passed digits. SayDigits is using the
current language setting for the channel. (See app setLanguage)

</usage>
    </application>
    <application name="MailboxExists">
        <synopsis>Check if vmbox exists</synopsis>
        <usage>  MailboxExists(mailbox[@context]): Conditionally branches to priority n+101
if the specified voice mailbox exists.

</usage>
    </application>
    <application name="Goto">
        <synopsis>Goto a particular priority, extension, or context</synopsis>
        <usage>  Goto([[context|]extension|]priority):  Set the  priority to the specified
value, optionally setting the extension and optionally the context as well.
The extension BYEXTENSION is special in that it uses the current extension,
thus  permitting you to go to a different context, without specifying a
specific extension. Always returns 0, even if the given context, extension,
or priority is invalid.

</usage>
    </application>
    <application name="MeetMe">
        <synopsis>MeetMe conference bridge</synopsis>
        <usage>  MeetMe([confno][,[options][,pin]]): Enters the user into a specified MeetMe conference.
If the conference number is omitted, the user will be prompted to enter
one. 
MeetMe returns 0 if user pressed # to exit (see option &#39;p&#39;), otherwise -1.
Please note: A ZAPTEL INTERFACE MUST BE INSTALLED FOR CONFERENCING TO WORK!

The option string may contain zero or more of the following characters:
      &#39;m&#39; -- set monitor only mode (Listen only, no talking)
      &#39;t&#39; -- set talk only mode. (Talk only, no listening)
      &#39;p&#39; -- allow user to exit the conference by pressing &#39;#&#39;
      &#39;X&#39; -- allow user to exit the conference by entering a valid single
             digit extension ${MEETME_EXIT_CONTEXT} or the current context
             if that variable is not defined.
      &#39;d&#39; -- dynamically add conference
      &#39;D&#39; -- dynamically add conference, prompting for a PIN
      &#39;e&#39; -- select an empty conference
      &#39;E&#39; -- select an empty pinless conference
      &#39;v&#39; -- video mode
      &#39;q&#39; -- quiet mode (don&#39;t play enter/leave sounds)
      &#39;M&#39; -- enable music on hold when the conference has a single caller
      &#39;x&#39; -- close the conference when last marked user exits
      &#39;w&#39; -- wait until the marked user enters the conference
      &#39;b&#39; -- run AGI script specified in ${MEETME_AGI_BACKGROUND}
         Default: conf-background.agi
        (Note: This does not work with non-Zap channels in the same conference)
      &#39;s&#39; -- Present menu (user or admin) when &#39;*&#39; is received (&#39;send&#39; to menu)
      &#39;a&#39; -- set admin mode
      &#39;A&#39; -- set marked mode

</usage>
    </application>
    <application name="SetGlobalVar">
        <synopsis>Set global variable to value</synopsis>
        <usage>  SetGlobalVar(#n=value): Sets global variable n to value. Global
variable are available across channels.

</usage>
    </application>
    <application name="SoftHangup">
        <synopsis>Soft Hangup Application</synopsis>
        <usage>  SoftHangup(Technology/resource)
Hangs up the requested channel.  Always returns 0

</usage>
    </application>
    <application name="SetCDRUserField">
        <synopsis>Set the CDR user field</synopsis>
        <usage>[Synopsis]
SetCDRUserField(value)

[Description]
SetCDRUserField(value): Set the CDR &#39;user field&#39; to value
       The Call Data Record (CDR) user field is an extra field you
       can use for data not stored anywhere else in the record.
       CDR records can be used for billing or storing other arbitrary data
       (I.E. telephone survey responses)
       Also see AppendCDRUserField().
       Always returns 0

</usage>
    </application>
    <application name="Ringing">
        <synopsis>Indicate ringing tone</synopsis>
        <usage>  Ringing(): Request that the channel indicate ringing tone to the user.
Always returns 0.

</usage>
    </application>
    <application name="System">
        <synopsis>Execute a system command</synopsis>
        <usage>  System(command): Executes a command  by  using  system(). Returns -1 on
failure to execute the specified command. If  the command itself executes
but is in error, and if there exists a priority n + 101, where &#39;n&#39; is the
priority of the current instance, then  the  channel  will  be  setup  to
continue at that priority level.  Otherwise, System returns 0.

</usage>
    </application>
    <application name="VoiceMail2">
        <synopsis>Leave a voicemail message</synopsis>
        <usage>  VoiceMail([s|u|b]extension[@context][&amp;extension[@context]][...]):  Leavesvoicemail for a given extension (must be configured in voicemail.conf).
 If the extension is preceded by 
* &#39;s&#39; then instructions for leaving the message will be skipped.
* &#39;u&#39; then the &quot;unavailable&quot; message will be played.
  (/var/lib/asterisk/sounds/vm/&lt;exten&gt;/unavail) if it exists.
* &#39;b&#39; then the the busy message will be played (that is, busy instead of unavail).
If the caller presses &#39;0&#39; (zero) during the prompt, the call jumps to
extension &#39;o&#39; in the current context.
If the caller presses &#39;*&#39; during the prompt, the call jumps to
extension &#39;a&#39; in the current context.
If the requested mailbox does not exist, and there exists a priority
n + 101, then that priority will be taken next.
When multiple mailboxes are specified, the unavailable or busy message
will be taken from the first mailbox specified.
Returns -1 on error or mailbox not found, or if the user hangs up.
Otherwise, it returns 0.

</usage>
    </application>
    <application name="DigitTimeout">
        <synopsis>Set maximum timeout between digits</synopsis>
        <usage>  DigitTimeout(seconds): Set the maximum amount of time permitted between
digits when the user is typing in an extension. When this timeout expires,
after the user has started to type in an extension, the extension will be
considered complete, and will be interpreted. Note that if an extension
typed in is valid, it will not have to timeout to be tested, so typically
at the expiry of this timeout, the extension will be considered invalid
(and thus control would be passed to the &#39;i&#39; extension, or if it doesn&#39;t
exist the call would be terminated). The default timeout is 5 seconds.
Always returns 0.

</usage>
    </application>
    <application name="ZapScan">
        <synopsis>Scan Zap channels to monitor calls</synopsis>
        <usage>  ZapScan allows a call center manager to monitor Zap channels in
a convenient way.  Use &#39;#&#39; to select the next channel and use &#39;*&#39; to exit

</usage>
    </application>
    <application name="TrySystem">
        <synopsis>Try executing a system command</synopsis>
        <usage>  TrySystem(command): Executes a command  by  using  system(). Returns 0
on any situation. If  the command itself executes but is in error, and if
there exists a priority n + 101, where &#39;n&#39; is the priority of the current
instance, then  the  channel  will  be  setup  to continue at that
priority level.  Otherwise, System returns 0.

</usage>
    </application>
    <application name="SetAMAFlags">
        <synopsis>Sets AMA Flags</synopsis>
        <usage>  SetAMAFlags([flag]):  Set  the  channel AMA Flags for billing
purposes. Always returns 0.

</usage>
    </application>
    <application name="WaitForRing">
        <synopsis>Wait for Ring Application</synopsis>
        <usage>  WaitForRing(timeout)
Returns 0 after waiting at least timeout seconds. and
only after the next ring has completed.  Returns 0 on
success or -1 on hangup

</usage>
    </application>
    <application name="Prefix">
        <synopsis>Prepend leading digits</synopsis>
        <usage>  Prefix(digits): Prepends the digit string specified by digits to the
channel&#39;s associated extension. For example, the number 1212 when prefixed
with &#39;555&#39; will become 5551212. This app always returns 0, and the PBX will
continue processing at the next priority for the *new* extension.
  So, for example, if priority  3  of 1212 is  Prefix  555, the next step
executed will be priority 4 of 5551212. If you switch into an extension
which has no first step, the PBX will treat it as though the user dialed an
invalid extension.

</usage>
    </application>
    <application name="AppendCDRUserField">
        <synopsis>Append to the CDR user field</synopsis>
        <usage>[Synopsis]
AppendCDRUserField(value)

[Description]
AppendCDRUserField(value): Append value to the CDR user field
       The Call Data Record (CDR) user field is an extra field you
       can use for data not stored anywhere else in the record.
       CDR records can be used for billing or storing other arbitrary data
       (I.E. telephone survey responses)
       Also see SetCDRUserField().
       Always returns 0

</usage>
    </application>
    <application name="TXTCIDName">
        <synopsis>Lookup caller name from TXT record</synopsis>
        <usage>  TXTLookup(CallerID):  Looks up a Caller Name via DNS and sets
the variable &#39;TXTCIDNAME&#39;. TXTCIDName will either be blank
or return the value found in the TXT record in DNS.

</usage>
    </application>
    <application name="RxFAX">
        <synopsis>Receive a FAX to a file</synopsis>
        <usage>  RxFAX(filename): Receives a FAX from the channel into a
given filename. If the file exists it will be overwritten. The file
should be in TIFF/F format.
Uses LOCALSTATIONID to identify itself to the remote end.
     LOCALHEADERINFO to generate a header line on each page.
Sets REMOTESTATIONID to the sender CSID.
     FAXPAGES to the number of pages received.
     FAXBITRATE to the transmition rate.
     FAXRESOLUTION to the resolution.
Returns -1 when the user hangs up.

</usage>
    </application>
    <application name="Transfer">
        <synopsis>Transfer caller to remote extension</synopsis>
        <usage>  Transfer(exten):  Requests the remote caller be transferred to
a given extension. Returns -1 on hangup, or 0 on completion
regardless of whether the transfer was successful.  If the transfer
was *not* supported or successful and there exists a priority n + 101,
then that priority will be taken next.

</usage>
    </application>
    <application name="SetMusicOnHold">
        <synopsis>Set default Music On Hold class</synopsis>
        <usage>SetMusicOnHold(class): Sets the default class for music on hold for a given channel.  When
music on hold is activated, this class will be used to select which
music is played.

</usage>
    </application>
    <application name="MeetMeAdmin">
        <synopsis>MeetMe conference Administration</synopsis>
        <usage>  MeetMeAdmin(confno,command[,user]): Run admin command for conference
      &#39;K&#39; -- Kick all users out of conference
      &#39;k&#39; -- Kick one user out of conference
      &#39;L&#39; -- Lock conference
      &#39;l&#39; -- Unlock conference
      &#39;M&#39; -- Mute conference
      &#39;m&#39; -- Unmute conference

</usage>
    </application>
    <application name="SetVar">
        <synopsis>Set variable to value</synopsis>
        <usage>  Setvar(#n=value): Sets channel specific variable n to value
</usage>
    </application>
    <application name="Record">
        <synopsis>Record to a file</synopsis>
        <usage>  Record(filename:format|silence[|maxduration][|option])

Records from the channel into a given filename. If the file exists it will
be overwritten.
- &#39;format&#39; is the format of the file type to be recorded (wav, gsm, etc).
- &#39;silence&#39; is the number of seconds of silence to allow before returning.
- &#39;maxduration&#39; is the maximum recording duration in seconds. If missing
or 0 there is no maximum.
- &#39;option&#39; may be &#39;skip&#39; to return immediately if the line is not up,
or &#39;noanswer&#39; to attempt to record even if the line is not up.

If filename contains &#39;%d&#39;, these characters will be replaced with a number
incremented by one each time the file is recorded. 

Formats: g723, g729, gsm, h263, ulaw, alaw, vox, wav, WAV

User can press &#39;#&#39; to terminate the recording and continue to the next priority.

Returns -1 when the user hangs up.

</usage>
    </application>
    <application name="SetCIDNum">
        <synopsis>Set CallerID Number</synopsis>
        <usage>  SetCIDNum(cnum[|a]): Set Caller*ID Number on a call to a new
value, while preserving the original Caller*ID name.  This is
useful for providing additional information to the called
party. Sets ANI as well if a flag is used.  Always returns 0

</usage>
    </application>
    <application name="ResetCDR">
        <synopsis>Resets the Call Data Record</synopsis>
        <usage>  ResetCDR([options]):  Causes the Call Data Record to be reset, optionally
storing the current CDR before zeroing it out (if &#39;w&#39; option is specifed).
record WILL be stored.
Always returns 0.

</usage>
    </application>
    <application name="Playback">
        <synopsis>Play a file</synopsis>
        <usage>  Playback(filename[|option]):  Plays  back  a  given  filename (do not put
extension). Options may also be  included following a pipe symbol. The &#39;skip&#39;
option causes the playback of the message to  be  skipped  if  the  channel
is not in the &#39;up&#39; state (i.e. it hasn&#39;t been  answered  yet. If &#39;skip&#39; is 
specified, the application will return immediately should the channel not be
off hook.  Otherwise, unless &#39;noanswer&#39; is specified, the channel channel will
be answered before the sound is played. Not all channels support playing
messages while still hook. Returns -1 if the channel was hung up, or if the
file does not exist. Returns 0 otherwise.

</usage>
    </application>
    <application name="Macro">
        <synopsis>Macro Implementation</synopsis>
        <usage>  Macro(macroname|arg1|arg2...): Executes a macro using the context
&#39;macro-&lt;macroname&gt;&#39;, jumping to the &#39;s&#39; extension of that context and
executing each step, then returning when the steps end.  The calling
extension, context, and priority are stored in ${MACRO_EXTEN}, 
${MACRO_CONTEXT} and ${MACRO_PRIORITY} respectively.  Arguments become
${ARG1}, ${ARG2}, etc in the macro context.  Macro returns -1 if
any step in the macro returns -1, and 0 otherwise.  If you Goto out
of the Macro context, the Macro will terminate and control will be return
at the location of the Goto.  Otherwise if ${MACRO_OFFSET} is set at
termination, Macro will attempt to continue at priority
MACRO_OFFSET + N + 1 if such a step exists, and N + 1 otherwise.

</usage>
    </application>
    <application name="SIPDtmfMode">
        <synopsis>Change the dtmfmode for a SIP call</synopsis>
        <usage>SIPDtmfMode(inband|info|rfc2833): Changes the dtmfmode for a SIP call

</usage>
    </application>
    <application name="WaitExten">
        <synopsis>Waits for some time</synopsis>
        <usage>  Wait(seconds): Waits for the user to enter a new extension for the 
specified number of seconds, then returns 0.  Seconds can be passed with
fractions of a second. (eg: 1.5 = 1.5 seconds)

</usage>
    </application>
    <application name="Dial">
        <synopsis>Place a call and connect to the current channel</synopsis>
        <usage>  Dial(Technology/resource[&amp;Technology2/resource2...][|timeout][|options][|URL]):
Requests one or more channels and places specified outgoing calls on them.
As soon as a channel answers, the Dial app will answer the originating
channel (if it needs to be answered) and will bridge a call with the channel
which first answered. All other calls placed by the Dial app will be hung up
If a timeout is not specified, the Dial application will wait indefinitely
until either one of the called channels answers, the user hangs up, or all
channels return busy or error. In general, the dialer will return 0 if it
was unable to place the call, or the timeout expired. However, if all
channels were busy, and there exists an extension with priority n+101 (where
n is the priority of the dialer instance), then it will be the next
executed extension (this allows you to setup different behavior on busy from
no-answer).
  This application returns -1 if the originating channel hangs up, or if the
call is bridged and either of the parties in the bridge terminate the call.
The option string may contain zero or more of the following characters:
      &#39;t&#39; -- allow the called user transfer the calling user by hitting #.
      &#39;T&#39; -- allow the calling user to transfer the call by hitting #.
      &#39;f&#39; -- Forces callerid to be set as the extension of the line 
             making/redirecting the outgoing call. For example, some PSTNs
             don&#39;t allow callerids from other extensions then the ones
             that are assigned to you.
      &#39;r&#39; -- indicate ringing to the calling party, pass no audio until answered.
      &#39;m&#39; -- provide hold music to the calling party until answered.
      &#39;M(x) -- Executes the macro (x) upon connect of the call
      &#39;h&#39; -- allow callee to hang up by hitting *.
      &#39;H&#39; -- allow caller to hang up by hitting *.
      &#39;C&#39; -- reset call detail record for this call.
      &#39;P[(x)]&#39; -- privacy mode, using &#39;x&#39; as database if provided.
      &#39;g&#39; -- goes on in context if the destination channel hangs up
      &#39;e&#39; -- Force the caller to Explicitly accept the call
      &#39;A(x)&#39; -- play an announcement to the called party, using x as file
      &#39;S(x)&#39; -- hangup the call after x seconds AFTER called party picked up
      &#39;D([digits])&#39;  -- Send DTMF digit string *after* called party has answered
             but before the bridge. (w=500ms sec pause)
      &#39;L(x[:y][:z])&#39; -- Limit the call to &#39;x&#39; ms warning when &#39;y&#39; ms are left
             repeated every &#39;z&#39; ms) Only &#39;x&#39; is required, &#39;y&#39; and &#39;z&#39; are optional.
             The following special variables are optional:
             * LIMIT_PLAYAUDIO_CALLER    yes|no (default yes)
                                         Play sounds to the caller.
             * LIMIT_PLAYAUDIO_CALLEE    yes|no
                                         Play sounds to the callee.
             * LIMIT_TIMEOUT_FILE        File to play when time is up.
             * LIMIT_CONNECT_FILE        File to play when call begins.
             * LIMIT_WARNING_FILE        File to play as warning if &#39;y&#39; is defined.
                        &#39;timeleft&#39; is a special sound macro to auto-say the time 
                        left and is the default.

  In addition to transferring the call, a call may be parked and then picked
up by another user.
  The optional URL will be sent to the called party if the channel supports it.
  This application sets the following channel variables upon completion:
      DIALEDTIME    Time from dial to answer
      ANSWEREDTIME  Time for actual call
      DIALSTATUS    The status of the call as a text string, one of
             CHANUNAVAIL | CONGESTION | NOANSWER | BUSY | ANSWER | CANCEL

</usage>
    </application>
    <application name="ParkedCall">
        <synopsis>Answer a parked call</synopsis>
        <usage>ParkedCall(exten):Used to connect to a parked call.  This Application is always
registered internally and does not need to be explicitly added
into the dialplan, although you should include the &#39;parkedcalls&#39;
context.

</usage>
    </application>
    <application name="ResponseTimeout">
        <synopsis>Set maximum timeout awaiting response</synopsis>
        <usage>  ResponseTimeout(seconds): Set the maximum amount of time permitted after
falling through a series of priorities for a channel in which the user may
begin typing an extension. If the user does not type an extension in this
amount of time, control will pass to the &#39;t&#39; extension if it exists, and
if not the call would be terminated. The default timeout is 10 seconds.
Always returns 0.

</usage>
    </application>
    <application name="Hangup">
        <synopsis>Unconditional hangup</synopsis>
        <usage>  Hangup(): Unconditionally hangs up a given channel by returning -1 always.

</usage>
    </application>
    <application name="GotoIfTime">
        <synopsis>Conditional goto on current time</synopsis>
        <usage>  GotoIfTime(&lt;times&gt;|&lt;weekdays&gt;|&lt;mdays&gt;|&lt;months&gt;?[[context|]extension|]pri):
If the current time matches the specified time, then branch to the specified
extension. Each of the elements may be specified either as &#39;*&#39; (for always)
or as a range. See the &#39;include&#39; syntax for details.
</usage>
    </application>
    <application name="NoOp">
        <synopsis>No operation</synopsis>
        <usage>  NoOp(): No-operation; Does nothing.
</usage>
    </application>
    <application name="SetCallerPres">
        <synopsis>Set CallerID Presentation</synopsis>
        <usage>  SetCallerPres(presentation): Set Caller*ID presentation on
a call to a new value.  Sets ANI as well if a flag is used.
Always returns 0.  Valid presentations are:

      allowed_not_screened    : Presentation Allowed, Not Screened
      allowed_passed_screen   : Presentation Allowed, Passed Screen
      allowed_failed_screen   : Presentation Allowed, Failed Screen
      allowed                 : Presentation Allowed, Network Number
      prohib_not_screened     : Presentation Prohibited, Not Screened
      prohib_passed_screen    : Presentation Prohibited, Passed Screen
      prohib_failed_screen    : Presentation Prohibited, Failed Screen
      prohib                  : Presentation Prohibited, Network Number
      unavailable             : Number Unavailable


</usage>
    </application>
    <application name="SetLanguage">
        <synopsis>Sets user language</synopsis>
        <usage>  SetLanguage(language):  Set  the  channel  language to &#39;language&#39;.  This
information is used for the syntax in generation of numbers, and to choose
a natural language file when available.
  For example, if language is set to &#39;fr&#39; and the file &#39;demo-congrats&#39; is 
requested  to  be  played,  if the file &#39;fr/demo-congrats&#39; exists, then
it will play that file, and if not will play the normal &#39;demo-congrats&#39;.
Always returns 0.

</usage>
    </application>
    <application name="NoCDR">
        <synopsis>Make sure asterisk doesn&#39;t save CDR for a certain call</synopsis>
        <usage>NoCDR(): makes sure there won&#39;t be any CDR written for a certain call
</usage>
    </application>
    <application name="StripMSD">
        <synopsis>Strip leading digits</synopsis>
        <usage>  StripMSD(count): Strips the leading &#39;count&#39; digits from the channel&#39;s
associated extension. For example, the number 5551212 when stripped with a
count of 3 would be changed to 1212. This app always returns 0, and the PBX
will continue processing at the next priority for the *new* extension.
  So, for example, if priority 3 of 5551212 is StripMSD 3, the next step
executed will be priority 4 of 1212. If you switch into an extension which
has no first step, the PBX will treat it as though the user dialed an
invalid extension.

</usage>
    </application>
    <application name="Progress">
        <synopsis>Indicate progress</synopsis>
        <usage>  Progress(): Request that the channel indicate in-band progress is 
available to the user.
Always returns 0.

</usage>
    </application>
    <application name="ZapBarge">
        <synopsis>Barge in (monitor) Zap channel</synopsis>
        <usage>  ZapBarge([channel]): Barges in on a specified zap
channel or prompts if one is not specified.  Returns
-1 when caller user hangs up and is independent of the
state of the channel being monitored.
</usage>
    </application>
    <application name="GotoIf">
        <synopsis>Conditional goto</synopsis>
        <usage>  GotoIf(Condition?label1:label2): Go to label 1 if condition is
true, to label2 if condition is false. Either label1 or label2 may be
omitted (in that case, we just don&#39;t take the particular branch) but not
both. Look for the condition syntax in examples or documentation.
</usage>
    </application>
</asterisk>